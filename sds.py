stateMatrix = Gfield(np.array([[0x32, 0x88, 0x31, 0xe0],
                                   [0x43, 0x5a, 0x31, 0x37],
                                   [0xf6, 0x30, 0x98, 0x07],
                                   [0xa8, 0x8d, 0xa2, 0x34]]))

testKey = Gfield(np.array([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))

print("This is the original plaintext message represented as a 4x4 state matrix: \n", stateMatrix, "\n")

# Encrypt the state matrix using GCM mode
encryptedMsg = gcmEncrypt(stateMatrix, testKey, 0)
print("The encrypted message, including the authentication tag, is as follows: \n", encryptedMsg, "\n")

# Split the encrypted message into the ciphertext and tag
recivedMsg = encryptedMsg[:-16]
recievedTag = encryptedMsg[-16:]

print("First 16 bytes: This is the ciphertext (encrypted content): \n", recivedMsg, "\n")
print("Last 16 bytes: This is the authentication tag generated by GCM for integrity verification: \n", recievedTag, "\n")

# Compute the tag for the received message
computedTag = computeTag(recivedMsg, testKey, 0)
print("This is the authentication tag we compute independently based on the received ciphertext (first 16 bytes): \n", computedTag, "\n")

# Verify the tag
if np.array_equal(recievedTag, computedTag):
    print("By comparing - finding the difference between the computed tag (based on the first 16 bytes) with the last 16 tag bytes of the ciphertext the difference is zero, indicating that the tags match and are thus valid, message integrity is thereby verified. \n")
else:
    print("By comparing — finding the difference between the computed tag (based on the first 16 bytes) and the last 16 tag bytes of the ciphertext, a non-zero difference is found, indicating that the tags do not match and thus the message integrity is compromised. \n")

#Create an error message
errorMessage = encryptedMsg.copy()

#Inject an error into the error message

errorMessage[0] = 125
print("The encrypted message with deliberately made error in the first byte (set to 125): \n", errorMessage, "\n")

# Split the error message into the received message and tag
recivedMsgError = errorMessage[:-16]
recievedTagError = errorMessage[-16:]


print("First 16 bytes of the compromised ciphertext, which is the messagepart: \n", recivedMsgError, "\n")
print("Last 16 bytes of the compromised ciphertext, which is the authentication tag generated by GCM for integrity verification: \n", recievedTagError, "\n")

# Compute the tag for the received message with error
computedTagError = computeTag(recivedMsgError, testKey, 0)
print("This is the authentication tag we compute independently based on the first 16 bytes of the compromised ciphertext: \n", computedTagError, "\n")

# Verify the tag for the message with error
if np.array_equal(recievedTagError, computedTagError):
    print("By comparing - finding the difference between the computed tag (based on the first 16 bytes) with the last 16 tag bytes of the ciphertext the difference is zero, indicating that the tags match and are thus valid, message integrity is thereby verified. \n")
else:
    print("By comparing — finding the difference between the computed tag (based on the first 16 bytes) and the last 16 tag bytes of the ciphertext, a non-zero difference is found,  indicating that the tags do not match and thus the message integrity is compromised. \n")